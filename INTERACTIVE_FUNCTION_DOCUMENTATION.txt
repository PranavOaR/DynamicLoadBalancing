==============================================================================
INTERACTIVE LOAD BALANCER - COMPREHENSIVE FUNCTION DOCUMENTATION
==============================================================================

This document details every function in the interactive version of the
dynamic load balancer, organized by category with inputs, outputs, and 
algorithm descriptions.

==============================================================================
PART 1: INPUT VALIDATION & UTILITY FUNCTIONS
==============================================================================

---
FUNCTION: void clearBuffer()
---
PURPOSE:
  Clears the input buffer after user enters data. Prevents input overflow
  and allows fresh input for the next prompt.

INPUT PARAMETERS:
  (none)

RETURN VALUE:
  void (no return)

HOW IT WORKS:
  â€¢ Reads characters from stdin until newline (\n) or EOF
  â€¢ Useful after scanf() to clean leftover characters
  â€¢ Prevents "Invalid input!" messages when entering subsequent values

TIME COMPLEXITY:
  O(n) where n = number of characters in buffer (typically small)

EXAMPLE USAGE:
  scanf("%d", &value);
  clearBuffer();  // Clean any leftover characters

IMPORTANT NOTES:
  â€¢ Must be called AFTER every scanf() that reads a single item
  â€¢ Prevents cascading input errors
  â€¢ Essential for interactive menu systems

---
FUNCTION: int getIntInput(const char* prompt, int minVal, int maxVal)
---
PURPOSE:
  Safely reads an integer from user with validation and retry logic.
  Ensures input falls within specified range.

INPUT PARAMETERS:
  â€¢ prompt (const char*): Message to display to user
                         Example: "Enter number of servers (1-20): "
  â€¢ minVal (int): Minimum acceptable value (inclusive)
  â€¢ maxVal (int): Maximum acceptable value (inclusive)

RETURN VALUE:
  int: Valid integer between minVal and maxVal

HOW IT WORKS:
  1. Display prompt to user
  2. Attempt to read integer with scanf()
  3. If scanf fails: clear buffer, show error, retry
  4. If value outside range [minVal, maxVal]: show error, retry
  5. Return valid value when accepted

VALIDATION CHECKS:
  â€¢ scanf() returns 1 (successful read)
  â€¢ Value >= minVal AND value <= maxVal

TIME COMPLEXITY:
  O(k) where k = number of retry attempts (user-dependent)

EXAMPLE USAGE:
  int servers = getIntInput("Number of servers (1-20): ", 1, 20);
  // User enters "25" â†’ Error, retry
  // User enters "6" â†’ Returns 6

IMPORTANT NOTES:
  â€¢ Automatically retries on invalid input
  â€¢ User never sees unvalidated data
  â€¢ Prevents buffer overflow from malformed input

---
FUNCTION: float getFloatInput(const char* prompt, float minVal, float maxVal)
---
PURPOSE:
  Safely reads a floating-point number from user with validation and retry.
  Similar to getIntInput but for float values.

INPUT PARAMETERS:
  â€¢ prompt (const char*): Display message to user
  â€¢ minVal (float): Minimum acceptable value
  â€¢ maxVal (float): Maximum acceptable value

RETURN VALUE:
  float: Valid floating-point number in range [minVal, maxVal]

HOW IT WORKS:
  1. Display prompt
  2. Try scanf("%f", ...)
  3. If fails or out of range: clear buffer, show error, retry
  4. Return validated float

VALIDATION CHECKS:
  â€¢ scanf() successful
  â€¢ value >= minVal AND value <= maxVal

TIME COMPLEXITY:
  O(k) where k = retry attempts

EXAMPLE USAGE:
  float threshold = getFloatInput("Threshold (0.1-100%%): ", 0.1, 100.0);

IMPORTANT NOTES:
  â€¢ Handles floating-point precision
  â€¢ Useful for capacities, loads, percentages
  â€¢ Retries indefinitely until valid input

---
FUNCTION: char getYesNoInput(const char* prompt)
---
PURPOSE:
  Reads a Y/N response from user, handles case insensitivity.
  Returns standardized 'Y' or 'N'.

INPUT PARAMETERS:
  â€¢ prompt (const char*): Question to ask user
                         Example: "Auto-generate random servers"

RETURN VALUE:
  char: Either 'Y' or 'N' (uppercase)

HOW IT WORKS:
  1. Display prompt with " (Y/N): " suffix
  2. Read single character
  3. Convert to uppercase (yâ†’Y, nâ†’N)
  4. If neither: show error, retry
  5. Return standardized 'Y' or 'N'

CASE HANDLING:
  â€¢ Accepts: Y, y, N, n
  â€¢ Rejects: anything else
  â€¢ Returns: always uppercase Y or N

TIME COMPLEXITY:
  O(k) where k = retry attempts

EXAMPLE USAGE:
  char response = getYesNoInput("Auto-generate capacities");
  if (response == 'Y') { ... }

IMPORTANT NOTES:
  â€¢ User input: 'y' â†’ returns 'Y'
  â€¢ User input: 'N' â†’ returns 'N'
  â€¢ Invalid: 'maybe' â†’ error, retry

==============================================================================
PART 2: GRAPH FUNCTIONS (Enhanced with Validation)
==============================================================================

---
FUNCTION: Graph* createGraph(int numServers)
---
PURPOSE:
  Allocates and initializes a graph with numServers nodes.
  Uses adjacency list representation.

INPUT PARAMETERS:
  â€¢ numServers (int): Number of server nodes in graph (1-20)

RETURN VALUE:
  Graph*: Pointer to newly allocated Graph structure

HOW IT WORKS:
  1. Allocate Graph struct on heap
  2. Set numServers field
  3. Allocate array of Node* (one per server)
  4. Initialize all Node* to NULL (no edges yet)
  5. Return pointer to Graph

ALGORITHM:
  Graph = [NULL, NULL, NULL, ...]  (numServers entries)

TIME COMPLEXITY:
  O(numServers) for allocation and initialization

MEMORY ALLOCATION:
  â€¢ 1 Ã— Graph struct
  â€¢ 1 Ã— array of Node* pointers (numServers items)

EXAMPLE USAGE:
  Graph* network = createGraph(6);
  // Creates graph with 6 servers, no connections

IMPORTANT NOTES:
  â€¢ All servers start isolated (no edges)
  â€¢ Edges added later with addEdge()
  â€¢ Must be freed with freeGraph()

---
FUNCTION: int edgeExists(Graph* graph, int src, int dest)
---
PURPOSE:
  Checks if an edge already exists from src to dest.
  Used to prevent duplicate edges.

INPUT PARAMETERS:
  â€¢ graph (Graph*): Network topology
  â€¢ src (int): Source server ID
  â€¢ dest (int): Destination server ID

RETURN VALUE:
  int: 1 if edge exists, 0 if not

HOW IT WORKS:
  1. Start at graph->adjList[src]
  2. Traverse linked list of neighbors
  3. If serverId == dest found: return 1
  4. Reach end of list: return 0

TIME COMPLEXITY:
  O(degree) where degree = number of neighbors of src

EXAMPLE USAGE:
  if (!edgeExists(graph, 0, 1)) {
      addEdge(graph, 0, 1);  // Safe to add
  }

IMPORTANT NOTES:
  â€¢ Directed graph: (0â†’1) â‰  (1â†’0)
  â€¢ Prevents accidental duplicates
  â€¢ Used before every addEdge() call

---
FUNCTION: int addEdge(Graph* graph, int src, int dest)
---
PURPOSE:
  Adds directed edge from src to dest with validation.
  Prevents self-edges, out-of-range servers, and duplicates.

INPUT PARAMETERS:
  â€¢ graph (Graph*): Network topology
  â€¢ src (int): Source server (must be 0 to numServers-1)
  â€¢ dest (int): Destination server (must be 0 to numServers-1)

RETURN VALUE:
  int: 1 if edge added successfully, 0 if validation failed

VALIDATION CHECKS:
  1. src in range [0, numServers)
  2. dest in range [0, numServers)
  3. src â‰  dest (no self-edges)
  4. Edge doesn't already exist

ERROR MESSAGES:
  âŒ Server ID out of range! Valid range: 0-N
  âŒ Cannot add self-edge (Server X â†’ Server X)
  âŒ Edge already exists (Server X â†’ Server Y)

HOW IT WORKS (if valid):
  1. Create new Node with serverId = dest
  2. Insert at front of adjacency list for src
  3. Print success message
  4. Return 1

TIME COMPLEXITY:
  O(degree) for duplicate check + O(1) for insertion

EXAMPLE USAGE:
  if (addEdge(graph, 0, 2) == 1) {
      printf("Edge added successfully\n");
  } else {
      printf("Edge addition failed\n");
  }

IMPORTANT NOTES:
  â€¢ Always validates before adding
  â€¢ User-friendly error messages
  â€¢ Safe for interactive input

---
FUNCTION: void printGraph(Graph* graph)
---
PURPOSE:
  Displays network topology in human-readable format.
  Shows all servers and their connections.

INPUT PARAMETERS:
  â€¢ graph (Graph*): Network to display

RETURN VALUE:
  void (no return)

HOW IT WORKS:
  1. Print header box
  2. For each server i (0 to numServers-1):
     a. Print "Server i â†’ "
     b. Traverse adjacency list
     c. Print neighbor IDs separated by commas
     d. If no neighbors: print "(no connections)"
  3. Print footer box

OUTPUT FORMAT:
  â”Œâ”€â”€â”€ Server Network Topology â”€â”€â”€â”
  â”‚ Server 0 â†’ 1, 3, 5
  â”‚ Server 1 â†’ 0, 2
  â”‚ Server 2 â†’ (no connections)
  â”‚ ...
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

TIME COMPLEXITY:
  O(V + E) where V = numServers, E = number of edges

EXAMPLE USAGE:
  printGraph(networkGraph);

IMPORTANT NOTES:
  â€¢ Shows directed edges only
  â€¢ (0â†’1) displayed, but (1â†’0) requires separate edge
  â€¢ Used after topology configuration and after each simulation

---
FUNCTION: void freeGraph(Graph* graph)
---
PURPOSE:
  Deallocates all memory used by graph structure.
  Prevents memory leaks when graph no longer needed.

INPUT PARAMETERS:
  â€¢ graph (Graph*): Graph to deallocate

RETURN VALUE:
  void (no return)

HOW IT WORKS:
  1. For each server i in adjacency list:
     a. Traverse linked list of neighbors
     b. Free each Node one by one
  2. Free the adjacency list array
  3. Free the Graph struct itself

MEMORY FREED:
  â€¢ All Node structs in all adjacency lists
  â€¢ The Node* array
  â€¢ The Graph struct

TIME COMPLEXITY:
  O(V + E) for traversal and deallocation

EXAMPLE USAGE:
  freeGraph(networkGraph);
  networkGraph = NULL;

IMPORTANT NOTES:
  â€¢ Must be called before program exit
  â€¢ Prevents memory leaks in long-running systems
  â€¢ Set pointer to NULL after freeing (good practice)

==============================================================================
PART 3: MIN-HEAP FUNCTIONS (Unchanged from Original)
==============================================================================

All heap functions work identically to the non-interactive version:
  â€¢ createMinHeap(capacity)
  â€¢ insertHeap(heap, serverId, load)
  â€¢ extractMin(heap)
  â€¢ heapifyUp(heap, index)
  â€¢ heapifyDown(heap, index)
  â€¢ updateHeap(heap, serverId, newLoad)
  â€¢ freeMinHeap(heap)

See FUNCTION_DOCUMENTATION.txt for detailed specifications.

==============================================================================
PART 4: LOAD BALANCING FUNCTIONS (Unchanged from Original)
==============================================================================

All load balancing functions identical to non-interactive version:
  â€¢ calculateAverageLoad(servers[], numServers)
  â€¢ getLoadPercentage(server)
  â€¢ findMostLoadedServer(servers[], numServers)
  â€¢ findLeastLoadedServer(servers[], numServers)
  â€¢ rebalanceLoads(servers[], numServers, threshold, heap)
  â€¢ printServerStates(servers[], numServers)

See FUNCTION_DOCUMENTATION.txt for detailed specifications.

==============================================================================
PART 5: NEW INTERACTIVE INPUT FUNCTIONS
==============================================================================

---
FUNCTION: void inputServerConfigurations(Server** servers, 
                                         int* numServers, 
                                         Graph** graph)
---
PURPOSE:
  Interactively collects server count and capacity configuration.
  Allocates memory for servers and graph.

INPUT PARAMETERS:
  â€¢ servers (Server**): Pointer to servers array (will be allocated)
  â€¢ numServers (int*): Pointer to store number of servers
  â€¢ graph (Graph**): Pointer to graph (will be allocated)

RETURN VALUE:
  void (modifies via pointers)

HOW IT WORKS:
  1. Display "SERVER CONFIGURATION PHASE" header
  2. Prompt user for number of servers (1-20)
  3. Allocate memory:
     - Server array for numServers
     - Graph with numServers nodes
  4. Ask capacity mode:
     - 1 = Auto-generate random (80-120)
     - 2 = Manual entry per server
  5. Set each server:
     - id, capacity, currentLoad = 0
  6. Display all capacities

INTERACTIVE PROMPTS:
  "Enter number of servers (1-20): "
  "Select mode (1-2): "
  (If mode 2) "Server i capacity (50-200): "

OUTPUT:
  âœ“ Auto-generating...
  â€¢ Server 0: Capacity = 105.42
  â€¢ Server 1: Capacity = 98.15
  ...
  
  OR
  
  âœ“ Enter capacity for each server:
  (User enters each)

TIME COMPLEXITY:
  O(numServers) for allocation and initialization

MEMORY ALLOCATION:
  â€¢ numServers Ã— Server structs
  â€¢ 1 Ã— Graph with numServers nodes

EXAMPLE USAGE:
  Server* servers;
  int numServers;
  Graph* graph;
  
  inputServerConfigurations(&servers, &numServers, &graph);

IMPORTANT NOTES:
  â€¢ Modifies through pointers (call-by-reference)
  â€¢ Allocates all necessary structures
  â€¢ Ready for topology configuration after

---
FUNCTION: void inputGraphTopology(Graph* graph, int numServers)
---
PURPOSE:
  Interactively configures network topology.
  User chooses: auto-random or manual edge entry.

INPUT PARAMETERS:
  â€¢ graph (Graph*): Graph to populate with edges
  â€¢ numServers (int): Number of servers (for validation)

RETURN VALUE:
  void (modifies graph)

HOW IT WORKS:
  1. Display "NETWORK TOPOLOGY CONFIGURATION" header
  2. Ask: "Auto-generate random network connections"
  
  IF YES:
    a. For each server 0 to numServers-1:
       - Generate 1-3 random neighbors
       - Check edge doesn't exist, not self-edge
       - Call addEdge() if valid
    b. Print resulting topology
  
  IF NO:
    a. Enter manual mode
    b. Instructions: "Enter edges as: source destination"
    c. Loop until user enters -1:
       - Read two integers: src, dest
       - Call addEdge(graph, src, dest)
       - Validate automatically in addEdge()
    d. Print resulting topology

INTERACTIVE PROMPTS (Auto-generate):
  "Auto-generate random network connections (Y/N): "

INTERACTIVE PROMPTS (Manual):
  "Enter edge (or -1 to finish): "
  (User enters: "0 1" for Server 0 â†’ Server 1)

OUTPUT:
  âœ“ Generating random network topology...
  âœ“ Added edge: Server 0 â†’ 3
  âœ“ Added edge: Server 1 â†’ 0
  ...
  
  â”Œâ”€â”€â”€ Server Network Topology â”€â”€â”€â”
  â”‚ Server 0 â†’ 3, 1, 5
  â”‚ ...
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

TIME COMPLEXITY:
  O(numServers) for auto mode + O(numEdges) for manual

VALIDATION IN MANUAL MODE:
  â€¢ Server IDs in range [0, numServers-1]
  â€¢ No self-edges
  â€¢ No duplicate edges
  â€¢ Invalid input caught and retried

EXAMPLE USAGE:
  Graph* graph = createGraph(6);
  inputGraphTopology(graph, 6);
  
  User chooses auto:
    âœ“ Random topology created with 6-18 edges
  
  User chooses manual:
    Enter: 0 1 (adds Server 0 â†’ 1)
    Enter: 0 2 (adds Server 0 â†’ 2)
    Enter: -1 (stops input)

IMPORTANT NOTES:
  â€¢ Auto mode prevents most invalid configurations
  â€¢ Manual mode validates every edge
  â€¢ User-friendly error messages guide corrections

---
FUNCTION: void inputTaskLoads(TaskData* taskData, int numTasks)
---
PURPOSE:
  Interactively configures task load values for simulation.
  User chooses: auto-random or manual entry.

INPUT PARAMETERS:
  â€¢ taskData (TaskData*): Pointer to TaskData structure
  â€¢ numTasks (int): Number of tasks to configure

RETURN VALUE:
  void (modifies TaskData via pointer)

HOW IT WORKS:
  1. Display "TASK LOAD CONFIGURATION" header
  2. Set taskData->numTasks = numTasks
  3. Allocate taskData->taskLoads array (numTasks floats)
  4. Ask: "Task Load Generation Mode"
     - 1 = Auto-random (5-15 units)
     - 2 = Manual entry
  
  IF MODE 1 (Auto):
    a. For each task 0 to numTasks-1:
       - Generate random: 5.0 + rand()*10.0
       - Store in taskData->taskLoads[i]
       - Print: "Task i: Load = X.XX"
  
  IF MODE 2 (Manual):
    a. For each task 0 to numTasks-1:
       - Prompt user: "Task i load (0.1-50): "
       - Read and validate with getFloatInput()
       - Store in taskData->taskLoads[i]

INTERACTIVE PROMPTS:
  "Select mode (1-2): "
  (If mode 2) "Task i load (0.1-50): "

OUTPUT (Auto):
  âœ“ Generating random task loads...
  â€¢ Task 1: Load = 7.23
  â€¢ Task 2: Load = 11.45
  ...

OUTPUT (Manual):
  âœ“ Enter load for each task:
  Task 1 load (0.1-50): (user enters)
  ...

TIME COMPLEXITY:
  O(numTasks) for allocation and generation/input

MEMORY ALLOCATION:
  â€¢ numTasks Ã— float (taskData->taskLoads)

EXAMPLE USAGE:
  TaskData taskData;
  inputTaskLoads(&taskData, 30);
  // taskData.taskLoads[0..29] populated

IMPORTANT NOTES:
  â€¢ Manual mode validates each entry (0.1-50 range)
  â€¢ Auto mode creates consistent random values
  â€¢ Later used by runInteractiveSimulation()
  â€¢ Must be freed with free(taskData.taskLoads)

---
FUNCTION: void inputRebalancingSettings(float* threshold, int* interval)
---
PURPOSE:
  Interactively configures rebalancing parameters.
  User specifies threshold and interval.

INPUT PARAMETERS:
  â€¢ threshold (float*): Pointer to store imbalance threshold (%)
  â€¢ interval (int*): Pointer to store rebalance interval (tasks)

RETURN VALUE:
  void (modifies via pointers)

HOW IT WORKS:
  1. Display "REBALANCING CONFIGURATION" header
  2. Prompt: "Rebalance threshold (0.1-100%%): "
     - Read and validate with getFloatInput()
     - Store in *threshold
  3. Prompt: "Rebalance interval (every N tasks, 1-100): "
     - Read and validate with getIntInput()
     - Store in *interval
  4. Display confirmation:
     - Threshold: X.XX%
     - Interval: Every N tasks

INTERACTIVE PROMPTS:
  "Rebalance threshold (0.1-100%%): "
  "Rebalance interval (every N tasks, 1-100): "

OUTPUT:
  âœ“ Rebalancing settings configured:
    Threshold: 20.00%
    Interval: Every 5 tasks

TIME COMPLEXITY:
  O(1) for user input and validation

EXAMPLE USAGE:
  float threshold;
  int interval;
  inputRebalancingSettings(&threshold, &interval);
  // threshold = 20.0, interval = 5

IMPORTANT NOTES:
  â€¢ Threshold: % imbalance before rebalancing triggered
  â€¢ Interval: After how many tasks to check/rebalance
  â€¢ Lower threshold = more aggressive rebalancing
  â€¢ Smaller interval = more frequent checks

---
FUNCTION: void printSimulationSummary(Server servers[], int numServers,
                                      Graph* graph, int numTasks,
                                      float threshold, int interval)
---
PURPOSE:
  Displays complete simulation configuration before execution.
  Lets user review all settings in one place.

INPUT PARAMETERS:
  â€¢ servers[] (Server[]): Array of server configurations
  â€¢ numServers (int): Number of servers
  â€¢ graph (Graph*): Network topology
  â€¢ numTasks (int): Number of tasks
  â€¢ threshold (float): Rebalance threshold (%)
  â€¢ interval (int): Rebalance interval (tasks)

RETURN VALUE:
  void (display only)

HOW IT WORKS:
  1. Print "SIMULATION CONFIGURATION SUMMARY" header
  2. Print SYSTEM CONFIGURATION:
     - Number of servers
     - Number of tasks
  3. Print SERVER CAPACITIES:
     - Server 0: 105.42
     - Server 1: 98.15
     - ...
  4. Print NETWORK TOPOLOGY:
     - Server 0 â†’ [neighbors...]
     - ...
  5. Print REBALANCING SETTINGS:
     - Threshold: X.XX%
     - Interval: Every N tasks

OUTPUT FORMAT:
  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•‘     SIMULATION CONFIGURATION SUMMARY    â•‘
  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  ğŸ“Š SYSTEM CONFIGURATION
     â€¢ Number of servers: 6
     â€¢ Number of tasks: 30
  
  ğŸ“¦ SERVER CAPACITIES
     â€¢ Server 0: 105.42
     ...
  
  ğŸŒ NETWORK TOPOLOGY
     â€¢ Server 0 â†’ 3, 1, 5
     ...
  
  âš™ï¸  REBALANCING SETTINGS
     â€¢ Threshold: 20.00%
     â€¢ Interval: Every 5 tasks

TIME COMPLEXITY:
  O(V + E) for printing graph

EXAMPLE USAGE:
  printSimulationSummary(servers, 6, graph, 30, 20.0, 5);

IMPORTANT NOTES:
  â€¢ User sees this BEFORE simulation starts
  â€¢ Chance to catch configuration errors
  â€¢ Followed by "Start simulation? (Y/N)" prompt

---
FUNCTION: void runInteractiveSimulation(Server servers[], Graph* graph,
                                        int numServers, TaskData* taskData,
                                        float threshold, int interval)
---
PURPOSE:
  Executes the interactive simulation with step-by-step control.
  User can assign tasks one at a time, all at once, or manage manually.

INPUT PARAMETERS:
  â€¢ servers[] (Server[]): Array of servers
  â€¢ graph (Graph*): Network topology (informational)
  â€¢ numServers (int): Number of servers
  â€¢ taskData (TaskData*): Pre-configured task loads
  â€¢ threshold (float): Rebalance threshold (%)
  â€¢ interval (int): Rebalance interval

RETURN VALUE:
  void (modifies servers[] via side effects)

HOW IT WORKS:

  Initialization:
    1. Create min-heap with all servers
    2. Insert each server with load = 0
    3. Set tasksAssigned = 0
  
  Main Loop (while tasksAssigned < numTasks):
    1. Display menu:
       1. Assign next task
       2. Assign all remaining tasks
       3. Trigger manual rebalance
       4. Show server status
       5. Exit simulation
    
    2. Get user choice and execute:
    
       CHOICE 1 - Assign next task:
         a. Get current task load from taskData
         b. Extract min-load server from heap
         c. Assign task: server.currentLoad += taskLoad
         d. Reinsert server into heap
         e. Display assignment details
         f. If (tasksAssigned % interval == 0): rebalance
         g. Increment tasksAssigned
       
       CHOICE 2 - Assign all remaining:
         a. Loop from tasksAssigned to numTasks:
            - Repeat CHOICE 1 steps b-g
         b. Exit loop when done
       
       CHOICE 3 - Trigger manual rebalance:
         a. Call rebalanceLoads() immediately
         b. No automatic check needed
       
       CHOICE 4 - Show server status:
         a. Call printServerStates()
         b. Display all server loads
       
       CHOICE 5 - Exit:
         a. Set tasksAssigned = numTasks
         b. Break loop
  
  Finalization:
    1. Print "FINAL LOAD DISTRIBUTION"
    2. Call printServerStates()
    3. Calculate statistics:
       - Average load
       - Max/min loads
       - Imbalance
    4. Display summary assessment
    5. Free heap

INTERACTIVE MENU:
  â”Œâ”€â”€â”€ Simulation Menu â”€â”€â”€â”
  â”‚ 1. Assign next task
  â”‚ 2. Assign all remaining tasks
  â”‚ 3. Trigger manual rebalance
  â”‚ 4. Show server status
  â”‚ 5. Exit simulation
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

TASK ASSIGNMENT OUTPUT:
  âœ“ Task 1 assigned to Server 0
    Load: 9.90/98.05 (10.1%)

REBALANCING OUTPUT:
  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•‘ âš ï¸  REBALANCING TRIGGERED âš ï¸       â•‘
  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     Imbalance: 23.45% (threshold: 20.00%)
     Server 3 (28.5%) â†’ Server 1 (5.2%)
     Migrating 8.75 load units
     âœ“ Rebalancing complete

FINAL OUTPUT:
  ğŸ“ˆ Final Statistics:
     Average Load: 51.23
     Max Load: 56.59 | Min Load: 48.27
     Load Difference: 8.32
  
  âœ“âœ“âœ“ System is WELL-BALANCED âœ“âœ“âœ“

TIME COMPLEXITY:
  Per task assignment: O(log n) for heap operations
  Total with k tasks: O(k log n)
  Manual rebalance: O(n) 
  Full simulation (all k tasks): O(k log n + rebalances Ã— n)

EXAMPLE USAGE:
  runInteractiveSimulation(servers, graph, 6, &taskData, 20.0, 5);
  
  User menu interaction:
    Choose: 1 (assign one)
    Choose: 2 (assign rest)
    Choose: 4 (show status)
    Choose: 5 (exit)

IMPORTANT NOTES:
  â€¢ User has full control over simulation flow
  â€¢ Can observe heap behavior step-by-step
  â€¢ Manual rebalance lets user test algorithm
  â€¢ All original algorithms unchanged
  â€¢ Can exit before all tasks assigned

==============================================================================
USAGE EXAMPLE WALKTHROUGH
==============================================================================

Program Execution Flow:

1. STARTUP
   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
   â•‘   DYNAMIC LOAD BALANCER - INTERACTIVE VERSION              â•‘
   â”‚   Distributed System Simulation                            â”‚
   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

2. SERVER CONFIGURATION
   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
   â•‘     SERVER CONFIGURATION PHASE             â•‘
   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   
   Enter number of servers (1-20): 6
   
   ğŸ”¹ Server Capacity Configuration
   1. Auto-generate random capacities (80-120)
   2. Enter each server capacity manually
   Select mode (1-2): 1
   
   âœ“ Generating random capacities...
   Server 0: Capacity = 105.42
   ...

3. TASK CONFIGURATION
   Enter number of tasks (1-1000): 30
   
   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
   â•‘       TASK LOAD CONFIGURATION              â•‘
   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   
   Select mode (1-2): 1
   âœ“ Generating random task loads...

4. REBALANCING SETTINGS
   Rebalance threshold (0.1-100%%): 20
   Rebalance interval (every N tasks, 1-100): 5

5. TOPOLOGY
   Auto-generate random network connections (Y/N): Y
   âœ“ Generating random network topology...

6. SUMMARY & CONFIRMATION
   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
   â•‘     SIMULATION CONFIGURATION SUMMARY        â•‘
   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   
   ğŸ“Š SYSTEM CONFIGURATION
      â€¢ Number of servers: 6
      â€¢ Number of tasks: 30
   
   ... (all settings)
   
   Start simulation (Y/N): Y

7. INTERACTIVE SIMULATION
   â”Œâ”€â”€â”€ Simulation Menu â”€â”€â”€â”
   â”‚ 1. Assign next task
   â”‚ 2. Assign all remaining tasks
   â”‚ 3. Trigger manual rebalance
   â”‚ 4. Show server status
   â”‚ 5. Exit simulation
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   
   Choose action (1-5): 2
   
   âœ“ Assigning all remaining 30 tasks...
   Task  1 â†’ Server 0 | Load: 9.90/105.42 (9.4%)
   Task  2 â†’ Server 5 | Load: 12.34/96.71 (12.8%)
   ...
   Task 30 â†’ Server 2 | Load: 56.59/111.98 (50.5%)

8. FINAL STATE
   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
   â•‘    FINAL LOAD DISTRIBUTION                  â•‘
   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   
   ğŸ“ˆ Final Statistics:
      Average Load: 51.23
      Max Load: 56.59 | Min Load: 48.27
      Load Difference: 8.32
   
   âœ“âœ“âœ“ System is WELL-BALANCED âœ“âœ“âœ“

9. CLEANUP
   âœ“ Resources freed. Program terminated.

==============================================================================
